// prisma/schema.prisma

generator client {
  provider = "prisma-client-js"
  output   = "../lib/generated/prisma"
}

datasource db {
  provider          = "postgresql"
  url               = env("DATABASE_URL")
  directUrl         = env("DATABASE_URL_DIRECT")
  shadowDatabaseUrl = env("SHADOW_DATABASE_URL")
}

/**
 * =========================
 * CORE v1 (Multi-tenant)
 * =========================
 */

enum UserRole {
  OWNER
  ADMIN
  DOCTOR
  STAFF
}

enum EncounterStatus {
  OPEN
  LOCKED
  SIGNED
}

enum SpecialtyType {
  GENERAL
  ENDODONTICS
  PERIODONTICS
  PROSTHODONTICS
  ORTHODONTICS
  IMPLANTS
  ORAL_SURGERY
  PEDIATRIC
  RADIOLOGY
}

model Clinic {
  id        String   @id @default(uuid())

  /// Código corto del tenant (ej: "clinica-hermano"). Único global.
  code      String   @unique

  name      String
  country   String?
  city      String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  users      User[]
  patients   Patient[]
  encounters Encounter[]
  audits     AuditLog[]

  @@index([createdAt])
}

model User {
  id       String   @id @default(uuid())
  clinicId String
  role     UserRole @default(STAFF)

  email    String
  fullName String?
  isActive Boolean @default(true)

  /// Auth (Email + Password)
  // Guardamos hash (bcrypt/argon2). Nunca plaintext.
  passwordHash       String?
  failedLoginCount   Int      @default(0)
  lockedUntil        DateTime?
  lastLoginAt        DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  clinic   Clinic            @relation(fields: [clinicId], references: [id], onDelete: Cascade)
  provider ProviderProfile?

  @@unique([clinicId, email])
  @@index([clinicId, role])
  @@index([clinicId, isActive])
}

model ProviderProfile {
  id            String         @id @default(uuid())
  userId        String         @unique
  licenseNumber String?

  /// Especialidad “principal” opcional (UI), pero permitimos múltiples via join table
  primarySpecialty SpecialtyType?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user        User               @relation(fields: [userId], references: [id], onDelete: Cascade)
  specialties ProviderSpecialty[]

  @@index([primarySpecialty])
}

model ProviderSpecialty {
  id         String        @id @default(uuid())
  providerId String
  specialty  SpecialtyType

  createdAt DateTime @default(now())

  provider ProviderProfile @relation(fields: [providerId], references: [id], onDelete: Cascade)

  @@unique([providerId, specialty])
  @@index([specialty])
}

model Patient {
  id       String @id @default(uuid())
  clinicId String

  // ID que pone el paciente (único por clínica)
  adieId String

  firstName      String
  lastName       String
  secondLastName String?
  dateOfBirth    DateTime?
  genderIdentity String?

  email   String?
  country String?
  city    String?

  mobilePhoneE164    String?
  otherPhoneE164     String?
  emergencyPhoneE164 String?

  relationship String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  clinic     Clinic      @relation(fields: [clinicId], references: [id], onDelete: Cascade)
  encounters Encounter[]

  @@unique([clinicId, adieId])
  @@index([clinicId, lastName, firstName])
  @@index([clinicId, createdAt])
}

model Encounter {
  id             String  @id @default(uuid())
  clinicId       String
  patientId      String
  providerUserId String?

  status EncounterStatus @default(OPEN)

  chiefComplaint String?
  notes          String?

  startedAt DateTime  @default(now())
  closedAt  DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  clinic  Clinic  @relation(fields: [clinicId], references: [id], onDelete: Cascade)
  patient Patient @relation(fields: [patientId], references: [id], onDelete: Cascade)

  specialtyNotes SpecialtyNote[]
  documents      Document[]
  aiOutputs      AIOutput[]

  @@index([clinicId, patientId, startedAt])
  @@index([clinicId, status])
}

model SpecialtyNote {
  id          String        @id @default(uuid())
  encounterId String
  specialty   SpecialtyType

  data    Json
  summary String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  encounter Encounter @relation(fields: [encounterId], references: [id], onDelete: Cascade)

  @@index([encounterId, specialty])
}

model Document {
  id          String @id @default(uuid())
  encounterId String

  type     String
  url      String
  metadata Json?

  createdAt DateTime @default(now())

  encounter Encounter @relation(fields: [encounterId], references: [id], onDelete: Cascade)

  @@index([encounterId, type])
}

model AIOutput {
  id          String @id @default(uuid())
  encounterId String

  kind      String
  model     String?
  inputHash String?
  output    String

  createdAt DateTime @default(now())

  encounter Encounter @relation(fields: [encounterId], references: [id], onDelete: Cascade)

  @@index([encounterId, kind, createdAt])
}

model AuditLog {
  id          String  @id @default(uuid())
  clinicId    String
  actorUserId String?

  action   String
  entity   String
  entityId String?
  meta     Json?

  createdAt DateTime @default(now())

  clinic Clinic @relation(fields: [clinicId], references: [id], onDelete: Cascade)

  @@index([clinicId, createdAt])
  @@index([clinicId, entity, entityId])
}
